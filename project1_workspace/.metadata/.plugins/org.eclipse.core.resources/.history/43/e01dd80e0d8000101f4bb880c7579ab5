//ì„œìš¸ê¸°ìˆ êµìœ¡ì„¼í„° AIOT & Embedded System
//2024-04-16 By KSH

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "esp.h"
#include <time.h>
#include "FreeRTOS.h"   // ì¶”ê°€
#include "task.h"       // ì¶”ê°€
#include "cmsis_os.h"

static char ip_addr[16];
char response[MAX_ESP_RX_BUFFER];

#define NTP_SERVER "time.kriss.re.kr"
#define NTP_PORT   123
#define NTP_PACKET_SIZE 48

//==================uart2=========================
extern UART_HandleTypeDef huart2;
extern UART_HandleTypeDef huart6;
extern osMutexId_t ESP_MutexHandle;
volatile unsigned char rx2Flag = 0;
volatile char rx2Data[50];
uint8_t cdata;

//==================uart6=========================
static uint8_t data;
cb_data_t cb_data;

int esp_at_command(uint8_t *cmd, uint8_t *resp, uint16_t *length, int16_t time_out)
{
	*length = 0;
	memset(resp, 0x00, MAX_UART_RX_BUFFER);
    taskENTER_CRITICAL();
    cb_data.length = 0;
    memset(cb_data.buf, 0, sizeof(cb_data.buf));
    taskEXIT_CRITICAL();

	// ëª…ë ¹ ì†¡ì‹ 
	if (HAL_UART_Transmit(&huart6, cmd, strlen((char *)cmd), 100) != HAL_OK)
		return -1;

	while (time_out > 0)
	{
		if (cb_data.length >= MAX_UART_RX_BUFFER) return -2;
		else if (strstr((char *)cb_data.buf, "ERROR") != NULL) return -3;
		else if (strstr((char *)cb_data.buf, "CLOSED") != NULL)   // ğŸ”¥ TCP ëŠê¹€ ê°ì§€
		{
			printf("ESP: TCP connection closed.\r\n");
			//esp_client_conn();   // ìë™ ì¬ì—°ê²°
			return -5;
		}
		else if (strstr((char *)cb_data.buf, "OK") != NULL)
		{
			memcpy(resp, cb_data.buf, cb_data.length);
			*length = cb_data.length;
			return 0;
		}

		time_out -= 10;
		HAL_Delay(10);
	}
	return -4; // Timeout
}

// í•œ ì¤„ì”© ESP ì‘ë‹µ ì½ê¸°

int esp_read_line(char *buf, int buf_size, int timeout_ms)
{
    int i = 0;
    int elapsed = 0;

    memset(buf, 0, buf_size);

    while (elapsed < timeout_ms)
    {
        if (cb_data.length > 0)
        {
            char c = cb_data.buf[0];

            // ë²„í¼ ì•ìœ¼ë¡œ ì´ë™
            memmove(cb_data.buf, cb_data.buf + 1, cb_data.length - 1);
            cb_data.length--;

            if (c == '\n' || c == '\r')
            {
                if (i == 0) // ë¹ˆ ì¤„ ë¬´ì‹œ
                    continue;
                buf[i] = 0;
                return i; // ì½ì€ ê¸¸ì´ ë°˜í™˜
            }

            if (i < buf_size - 1)
                buf[i++] = c;
        }
        else
        {
            HAL_Delay(1);
            elapsed += 1;
        }
    }
    return 0; // íƒ€ì„ì•„ì›ƒ
}


static int esp_reset(void)
{
    uint16_t length = 0;
    if(esp_at_command((uint8_t *)"AT+RST\r\n", (uint8_t *)response, &length, 1000) != 0)
    {
    	return -1;
    }
    else
    	HAL_Delay(500);	//reboot
    return 0;
}

static int esp_get_ip_addr(uint8_t is_debug)
{
    if(strlen(ip_addr) != 0)
    {
        if(strcmp(ip_addr, "0.0.0.0") == 0)
            return -1;
    }
    else
    {
        uint16_t length;
        if(esp_at_command((uint8_t *)"AT+CIPSTA?\r\n", (uint8_t *)response, &length, 1000) != 0)
            printf("ip_state command fail\r\n");
        else
        {
            char *line = strtok(response, "\r\n");

            if(is_debug)
            {
                for(int i = 0 ; i < length ; i++)
                    printf("%c", response[i]);
            }

            while(line != NULL)
            {
                if(strstr(line, "ip:") != NULL)
                {
                    char *ip;

                    strtok(line, "\"");
                    ip = strtok(NULL, "\"");
                    if(strcmp(ip, "0.0.0.0") != 0)
                    {
                        memset(ip_addr, 0x00, sizeof(ip_addr));
                        memcpy(ip_addr, ip, strlen(ip));
                        return 0;
                    }
                }
                line = strtok(NULL, "\r\n");
            }
        }

        return -1;
    }

    return 0;
}

static int request_ip_addr(uint8_t is_debug)
{
    uint16_t length = 0;

    if(esp_at_command((uint8_t *)"AT+CIFSR\r\n", (uint8_t *)response, &length, 1000) != 0)
        printf("request ip_addr command fail\r\n");
    else
    {
        char *line = strtok(response, "\r\n");

        if(is_debug)
        {
            for(int i = 0 ; i < length ; i++)
                printf("%c", response[i]);
        }

        while(line != NULL)
        {
            if(strstr(line, "CIFSR:STAIP") != NULL)
            {
                char *ip;

                strtok(line, "\"");
                ip = strtok(NULL, "\"");
                if(strcmp(ip, "0.0.0.0") != 0)
                {
                    memset(ip_addr, 0x00, sizeof(ip_addr));
                    memcpy(ip_addr, ip, strlen(ip));
                    return 0;
                }
            }
            line = strtok(NULL, "\r\n");
        }
    }
    return -1;
}

int esp_client_conn(void)
{
    char at_cmd[96]; uint16_t length=0;
    char line[128]; int n;

    // 1) TCP connect
    sprintf(at_cmd, "AT+CIPSTART=0,\"TCP\",\"%s\",%d\r\n", DST_IP, DST_PORT);
    if (esp_at_command((uint8_t*)at_cmd,(uint8_t*)response,&length,8000)!=0) return -1;

    // 2) "CONNECT" or "ALREADY" ëŒ€ê¸° (ìµœëŒ€ 5ì´ˆ)
    TickType_t deadline = xTaskGetTickCount() + pdMS_TO_TICKS(5000);
    int connected = 0;
    while (xTaskGetTickCount() < deadline) {
        n = esp_read_line(line, sizeof(line), 200);    // cb_dataì—ì„œ í•œ ì¤„ì”© ë½‘ê¸°
        if (n > 0) {
            if (strstr(line, "CONNECT") || strstr(line, "ALREADY")) { connected = 1; break; }
            if (strstr(line, "ERROR") || strstr(line, "FAIL")) return -2; // ì¦‰ì‹œ ì‹¤íŒ¨
        } else {
            // ì§§ê²Œ ì‰¬ê³  ë‹¤ì‹œ ì‹œë„
            vTaskDelay(pdMS_TO_TICKS(50));
        }
    }
    if (!connected) {
        // ìµœí›„ ìˆ˜ë‹¨: ìƒíƒœ í´ë§ìœ¼ë¡œ ì—°ê²° í™•ì¸
        if (esp_at_command((uint8_t*)"AT+CIPSTATUS\r\n",(uint8_t*)response,&length,700)!=0 ||
            !strstr((char*)response,"STATUS:3")) {
            return -3; // ì—°ê²° ì•ˆë¨
        }
    }

    // 3) ë¡œê·¸ì¸ payload ì „ì†¡
    char payload[64];
    snprintf(payload,sizeof(payload),"[%s:%s]", LOGID, PASSWD);

    sprintf(at_cmd,"AT+CIPSEND=0,%d\r\n",(int)strlen(payload));
    if (esp_at_command((uint8_t*)at_cmd,(uint8_t*)response,&length,3000)!=0) return -4;
    if (esp_at_command((uint8_t*)payload,(uint8_t*)response,&length,3000)!=0) return -5;

    return 0;
}


int esp_get_status(void)
{
    // 0 : Link0 connected
    // -1: Link0 not connected
    uint16_t length = 0;
    int ret = -1;

    if (osMutexAcquire(ESP_MutexHandle, 1000) == osOK) {
        if (esp_at_command((uint8_t*)"AT+CIPSTATUS\r\n", (uint8_t*)response, &length, 1500) == 0) {
            // MUX=1 ì‘ë‹µì—ì„œ "+CIPSTATUS:0,..." ë¼ì¸ì´ ìˆìœ¼ë©´ Link0ê°€ ì‹¤ì œ ì—°ê²° ìƒíƒœ
            if (strstr((char*)response, "+CIPSTATUS:0") &&
                (strstr((char*)response, "\"TCP\"") || strstr((char*)response, "\"UDP\""))) {
                ret = 0;
            } else {
                ret = -1;
            }
        }
        osMutexRelease(ESP_MutexHandle);
    }
    return ret;
}

 int drv_esp_init(void)
 {
     memset(ip_addr, 0x00, sizeof(ip_addr));
     memset(&cb_data, 0, sizeof(cb_data));
     HAL_UART_Receive_IT(&huart6, &data, 1);

     // ë¶€íŒ… ì§í›„ ì›Œë°ì—…: "AT" í•‘ 1~3íšŒ
     for (int i=0 ; i<3 ; i++) {
         uint16_t len=0;
         if (esp_at_command((uint8_t*)"AT\r\n",(uint8_t*)response,&len,500)==0) break;
         HAL_Delay(100);
     }
     return esp_reset();
 }

void reset_func()
{
	printf("esp reset... ");
	if(esp_reset() == 0)
			printf("OK\r\n");
	else
			printf("fail\r\n");
}

void version_func()
{
  uint16_t length = 0;
  printf("esp firmware version\r\n");
  if(esp_at_command((uint8_t *)"AT+GMR\r\n", (uint8_t *)response, &length, 1000) != 0)
      printf("ap scan command fail\r\n");
  else
  {
      for(int i = 0 ; i < length ; i++)
          printf("%c", response[i]);
  }
}

void ap_conn_func(char *ssid, char *passwd)
{
  uint16_t length=0; char at_cmd[MAX_ESP_COMMAND_LEN]={0};
  if(!ssid || !passwd){ printf("invalid command : ap_conn <ssid> <passwd>\r\n"); return; }

  esp_at_command((uint8_t*)"AT+CWMODE=1\r\n",(uint8_t*)response,&length,1500);
  esp_at_command((uint8_t*)"AT+CWQAP\r\n",(uint8_t*)response,&length,1500); HAL_Delay(200);

  sprintf(at_cmd, "AT+CWJAP=\"%s\",\"%s\"\r\n", ssid, passwd);
  int rc = esp_at_command((uint8_t*)at_cmd,(uint8_t*)response,&length,30000);
  if (rc!=0) {
    int ok=0;
    for (int i=0;i<10 && !ok;i++){
      if (esp_at_command((uint8_t*)"AT+CWJAP?\r\n",(uint8_t*)response,&length,1000)==0 &&
          strstr(response, "+CWJAP:")) {
        if (esp_at_command((uint8_t*)"AT+CIPSTA?\r\n",(uint8_t*)response,&length,1000)==0 &&
            !strstr(response, "ip:\"0.0.0.0\"")) { ok=1; break; }
      }
      HAL_Delay(1000);
    }
    if (!ok){ printf("ap join failed (no SSID/IP)\r\n"); return; }
  }
  printf("WIFI GOT IP\r\n");
}


void ip_state_func()
{
  uint16_t length = 0;
  if(esp_at_command((uint8_t *)"AT+CWJAP?\r\n", (uint8_t *)response, &length, 1000) != 0)
      printf("ap connected info command fail\r\n");
  else
  {
      for(int i = 0 ; i < length ; i++)
          printf("%c", response[i]);
  }
  printf("\r\n");

  if(esp_get_ip_addr(1) == 0)
      printf("ip_addr = [%s]\r\n", ip_addr);
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if(huart->Instance == USART6)  // ESP
    {
        if(cb_data.length < MAX_ESP_RX_BUFFER)
        {
            cb_data.buf[cb_data.length++] = data;
        }
        HAL_UART_Receive_IT(huart, &data, 1);
    }

    if(huart->Instance == USART2)  // ì½˜ì†”
    {
        static int i = 0;
        rx2Data[i] = cdata;
        if(rx2Data[i] == '\r')
        {
            rx2Data[i] = '\0';
            rx2Flag = 1;
            i = 0;
        }
        else
        {
            i++;
        }
        HAL_UART_Receive_IT(huart, &cdata, 1);
    }
}



void AiotClient_Init()
{
	reset_func();
	version_func();
	//ip_state_func();
	ap_conn_func(SSID,PASS);
	request_ip_addr(1);

    // â˜… ë©€í‹°ì»¤ë„¥ì…˜ ON
	uint16_t length = 0;
	esp_at_command((uint8_t*)"AT+CIPMUX=1\r\n", (uint8_t*)response, &length, 1000);
	//esp_client_conn();
	//esp_get_status();
}


void esp_send_data(char *data)
{
    char at_cmd[MAX_ESP_COMMAND_LEN] = {0, };
    uint16_t length = 0;

    sprintf(at_cmd,"AT+CIPSEND=0,%d\r\n",(int)strlen(data));
    if (esp_at_command((uint8_t*)at_cmd,(uint8_t*)response, &length, 1000) == 0) {
        esp_at_command((uint8_t*)data,(uint8_t*)response,&length,1000);
    }
}


//==================uart2=========================
int drv_uart_init(void)
{
    HAL_UART_Receive_IT(&huart2, &cdata,1);
    return 0;
}

int drv_uart_tx_buffer(uint8_t *buf, uint16_t size)
{
    if(HAL_UART_Transmit(&huart2, buf, size, 100) != HAL_OK)
        return -1;

    return 0;
}
int __io_putchar(int ch)
{
    if(HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 10) == HAL_OK)
        return ch;
    return -1;
}

// AT+CIPSNTPTIME? ê²°ê³¼ í•œ ì¤„ íŒŒì‹±
int parse_cipsntptime_line(const char *line, time_t *epoch_out)
{
    // ì˜ˆ: +CIPSNTPTIME:Thu Aug 17 15:24:30 2023
    struct tm tm_info;
    memset(&tm_info, 0, sizeof(struct tm));

    if (strstr(line, "+CIPSNTPTIME:") == NULL)
        return -1;

    // ë¬¸ìì—´ íŒŒì‹±
    char weekday[4], month[4];
    int day, year, hour, min, sec;

    int ret = sscanf(line, "+CIPSNTPTIME:%3s %3s %d %d:%d:%d %d",
                     weekday, month, &day, &hour, &min, &sec, &year);

    if (ret == 7)
    {
        if (strcmp(month, "Jan") == 0) tm_info.tm_mon = 0;
        else if (strcmp(month, "Feb") == 0) tm_info.tm_mon = 1;
        else if (strcmp(month, "Mar") == 0) tm_info.tm_mon = 2;
        else if (strcmp(month, "Apr") == 0) tm_info.tm_mon = 3;
        else if (strcmp(month, "May") == 0) tm_info.tm_mon = 4;
        else if (strcmp(month, "Jun") == 0) tm_info.tm_mon = 5;
        else if (strcmp(month, "Jul") == 0) tm_info.tm_mon = 6;
        else if (strcmp(month, "Aug") == 0) tm_info.tm_mon = 7;
        else if (strcmp(month, "Sep") == 0) tm_info.tm_mon = 8;
        else if (strcmp(month, "Oct") == 0) tm_info.tm_mon = 9;
        else if (strcmp(month, "Nov") == 0) tm_info.tm_mon = 10;
        else if (strcmp(month, "Dec") == 0) tm_info.tm_mon = 11;

        tm_info.tm_mday = day;
        tm_info.tm_hour = hour;
        tm_info.tm_min  = min;
        tm_info.tm_sec  = sec;
        tm_info.tm_year = year - 1900;

        *epoch_out = mktime(&tm_info);
        return 0;
    }
    return -1;
}

int esp_ntp_config(void)
{
    char cmd[128];
    sprintf(cmd, "AT+CIPSNTPCFG=1,9,\"%s\"\r\n", NTP_SERVER);
    if(HAL_UART_Transmit(&huart6, (uint8_t *)cmd, strlen(cmd), 100) != HAL_OK)
        return -1;

    vTaskDelay(pdMS_TO_TICKS(2000)); // ì„¤ì • ë°˜ì˜ ëŒ€ê¸°
    return 0;
}

int esp_link1_tcp_probe(const char *ip_or_host, int port)
{
    char cmd[128];
    uint16_t length = 0;

    // 1) ë§í¬1 ì—´ê¸°
    sprintf(cmd, "AT+CIPSTART=1,\"TCP\",\"%s\",%d\r\n", ip_or_host, port);
    if (esp_at_command((uint8_t*)cmd, (uint8_t*)response, &length, 5000) != 0) {
        printf("[LINK1] CIPSTART fail\r\n");
        return -1;
    }
    printf("[LINK1] CIPSTART OK\r\n");

    // 2) ë°”ë¡œ ë‹«ê¸° (ì—°ê²°ë§Œ í™•ì¸)
    esp_at_command((uint8_t*)"AT+CIPCLOSE=1\r\n", (uint8_t*)response, &length, 1000);
    return 0;
}

// esp.c
int esp_is_wifi_ready(void)
{
    uint16_t length = 0;
    int ok = 0;

    if (osMutexAcquire(ESP_MutexHandle, 1000) == osOK) {
        if (esp_at_command((uint8_t*)"AT+CWJAP?\r\n",(uint8_t*)response,&length,1000)==0 &&
            strstr((char*)response, "+CWJAP:")) {
            if (esp_at_command((uint8_t*)"AT+CIPSTA?\r\n",(uint8_t*)response,&length,1000)==0 &&
                !strstr((char*)response, "ip:\"0.0.0.0\"")) {
                ok = 1;
            }
        }
        osMutexRelease(ESP_MutexHandle);
    }
    return ok;
}




